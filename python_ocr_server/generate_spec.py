#!/usr/bin/env python3
"""
Generate PyInstaller spec file based on current operating system.
Handles platform-specific binary dependencies (dylib/so/dll).
"""

import platform
import sys
from pathlib import Path


def get_venv_site_packages():
    """Find the site-packages directory in the virtual environment."""
    # Get Python version
    py_version = f"python{sys.version_info.major}.{sys.version_info.minor}"

    # Check common venv locations
    venv_base = Path(__file__).parent.parent / ".venv"

    if platform.system() == "Windows":
        site_packages = venv_base / "Lib" / "site-packages"
    else:
        site_packages = venv_base / "lib" / py_version / "site-packages"

    if not site_packages.exists():
        print(f"Warning: site-packages not found at {site_packages}")
        # Fallback to direct import path
        import onnxruntime
        site_packages = Path(onnxruntime.__file__).parent.parent

    return site_packages


def get_onnxruntime_binaries():
    """Get OS-specific ONNX Runtime binary paths."""
    site_packages = get_venv_site_packages()
    onnx_capi = site_packages / "onnxruntime" / "capi"

    system = platform.system()
    binaries = []

    if system == "Darwin":  # macOS
        # Look for .dylib files
        dylib_files = list(onnx_capi.glob("libonnxruntime.*.dylib"))
        if dylib_files:
            binaries.append((str(dylib_files[0]), 'onnxruntime/capi'))

        # pybind11 state (usually .so even on macOS)
        pybind_file = onnx_capi / "onnxruntime_pybind11_state.so"
        if pybind_file.exists():
            binaries.append((str(pybind_file), 'onnxruntime/capi'))

    elif system == "Linux":
        # Look for .so files
        so_files = list(onnx_capi.glob("libonnxruntime.so.*"))
        if so_files:
            binaries.append((str(so_files[0]), 'onnxruntime/capi'))

        # pybind11 state
        pybind_file = onnx_capi / "onnxruntime_pybind11_state.so"
        if pybind_file.exists():
            binaries.append((str(pybind_file), 'onnxruntime/capi'))

    elif system == "Windows":
        # Look for .dll files
        dll_files = list(onnx_capi.glob("onnxruntime*.dll"))
        if dll_files:
            for dll in dll_files:
                binaries.append((str(dll), 'onnxruntime/capi'))

        # pybind11 state (usually .pyd on Windows)
        pyd_file = onnx_capi / "onnxruntime_pybind11_state.pyd"
        if pyd_file.exists():
            binaries.append((str(pyd_file), 'onnxruntime/capi'))

        # Also check for .so (sometimes present)
        so_file = onnx_capi / "onnxruntime_pybind11_state.so"
        if so_file.exists():
            binaries.append((str(so_file), 'onnxruntime/capi'))

    if not binaries:
        print(f"Warning: No ONNX Runtime binaries found for {system}")
        print(f"Searched in: {onnx_capi}")

    return binaries


def generate_spec():
    """Generate the PyInstaller spec file."""
    site_packages = get_venv_site_packages()
    binaries = get_onnxruntime_binaries()

    # Format binaries for spec file
    binaries_str = ",\n        ".join([f"('{src}', '{dst}')" for src, dst in binaries])

    spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
# Auto-generated by generate_spec.py for {platform.system()} ({platform.machine()})

block_cipher = None

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[
        # ONNX Runtime native libraries - OS-specific
        {binaries_str}
    ],
    datas=[
        # Include entire RapidOCR package with all resources
        ('{site_packages / "rapidocr"}', 'rapidocr'),
    ],
    hiddenimports=[
        # RapidOCR core
        'rapidocr',
        'rapidocr.main',
        'rapidocr.ch_ppocr_det',
        'rapidocr.ch_ppocr_rec',
        'rapidocr.ch_ppocr_cls',
        'rapidocr.cal_rec_boxes',
        'rapidocr.cal_rec_boxes.main',
        'rapidocr.ch_ppocr_rec.utils',
        'rapidocr.utils',
        # ONNX Runtime
        'onnxruntime',
        'onnxruntime.capi',
        'onnxruntime.capi.onnxruntime_pybind11_state',
        # FastAPI & dependencies
        'fastapi',
        'fastapi.responses',
        'uvicorn',
        'uvicorn.protocols',
        'uvicorn.protocols.http',
        'uvicorn.protocols.websockets',
        'uvicorn.lifespan',
        'uvicorn.lifespan.on',
        'starlette',
        'starlette.responses',
        'starlette.middleware',
        'starlette.middleware.cors',
        'pydantic',
        'pydantic.types',
        # Image processing
        'PIL',
        'PIL.Image',
        'PIL.ImageDraw',
        'PIL.ImageFont',
        'numpy',
        'numpy.core',
        'numpy.core._multiarray_umath',
        'cv2',
        # Other
        'yaml',
        'base64',
        'pathlib',
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='ocr_server',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='ocr_server'
)
'''

    return spec_content


if __name__ == "__main__":
    print(f"Generating PyInstaller spec for {platform.system()} ({platform.machine()})...")

    spec_content = generate_spec()
    spec_path = Path(__file__).parent / "ocr_server.spec"

    # Backup original spec if it exists
    if spec_path.exists():
        backup_path = spec_path.with_suffix(".spec.bak")
        spec_path.rename(backup_path)
        print(f"Backed up original spec to {backup_path}")

    # Write new spec
    spec_path.write_text(spec_content)
    print(f"Generated spec file: {spec_path}")

    # Show found binaries
    binaries = get_onnxruntime_binaries()
    if binaries:
        print(f"\nFound {len(binaries)} ONNX Runtime binaries:")
        for src, dst in binaries:
            print(f"  - {Path(src).name} -> {dst}")
    else:
        print("\nWarning: No ONNX Runtime binaries found!")
        sys.exit(1)
